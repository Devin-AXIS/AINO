# AINO 技术文档

## 开发约束与注意事项

> **注意**：详细的开发约束请参考 `docs/开发约束文档.md`，本文档主要关注技术架构和系统模块设计。

### 系统模块约束
1. **应用创建时自动包含系统模块** - 每个应用必须包含用户、配置、审计等基础模块
2. **系统模块配置要统一** - 通过`system-modules.ts`统一管理系统模块配置
3. **模块路由要规范化** - 系统模块通过`/api/modules/system/:moduleKey/*`统一路由
4. **模块权限要隔离** - 每个应用的模块权限要独立，不能跨应用访问

---

## 系统模块架构

### 📋 **核心设计**
- **系统模块**：每个应用创建时自动包含的基础模块（用户、配置、审计等）
- **模块路由系统**：通过`/api/modules/system/:moduleKey/*`统一访问系统模块
- **应用隔离**：每个应用的模块完全独立，通过`applicationId`隔离

### 🔧 **系统模块列表**

#### 1. **用户模块** (`user`)
- **功能**：用户注册、登录、权限管理
- **API路径**：`/api/modules/system/user/*`
- **配置**：注册策略、密码策略、默认角色等

#### 2. **配置模块** (`config`)
- **功能**：应用基础配置管理
- **API路径**：`/api/modules/system/config/*`
- **配置**：应用名称、描述、主题、语言等

#### 3. **审计模块** (`audit`)
- **功能**：记录用户操作和系统事件
- **API路径**：`/api/modules/system/audit/*`
- **配置**：日志级别、保留时间等

### 🏗️ **架构实现**

#### 1. **系统模块配置** (`src/lib/system-modules.ts`)
```typescript
export const DEFAULT_SYSTEM_MODULES: SystemModule[] = [
  {
    key: "user",
    name: "用户管理",
    type: "system",
    config: { allowRegistration: true, ... }
  },
  // ...
]
```

#### 2. **自动创建系统模块** (`src/modules/applications/service.ts`)
```typescript
async createApplication(data: CreateApplicationRequest, userId: string) {
  // 创建应用
  const [result] = await db.insert(applications).values(newApp).returning()
  
  // 自动创建系统模块
  await this.createSystemModules(result.id)
  
  return result
}
```

#### 3. **模块路由系统** (`src/modules/modules/routes.ts`)
```typescript
// 系统模块API路由
modulesRoute.all("/system/:moduleKey/*", requireAuthMiddleware, async (c) => {
  const moduleKey = c.req.param("moduleKey")
  const applicationId = c.req.query("applicationId")
  
  switch (moduleKey) {
    case "user":
      return await handleUserModule(c, path, applicationId, user)
    case "config":
      return await handleConfigModule(c, path, applicationId, user)
    // ...
  }
})
```

### 🔗 **API访问方式**

#### 直接访问（兼容性）
```
POST /api/users/login
GET /api/users/me
```

#### 模块路由访问（推荐）
```
POST /api/modules/system/user/login?applicationId=xxx
GET /api/modules/system/user/me?applicationId=xxx
```

### 📊 **数据库结构**
```sql
-- 应用表
applications (id, name, description, owner_id, ...)

-- 模块表（包含系统模块）
modules (id, application_id, name, type, config, ...)

-- 用户表（平台级）
users (id, name, email, password, roles, ...)

-- 应用成员关系表
application_members (id, application_id, user_id, role, ...)
```

### 🧪 **测试验证**
```bash
# 测试系统模块创建
node scripts/test-system-modules.js

# 测试模块API路由
node scripts/test-module-api.js
```

---

Hono + Drizzle + Postgres，一次只对接一个 API，模块可插拔，但整体极简，不过度工程化。下面给你一套"能落地、能长期演进"的最轻量架构蓝图 + 最小代码骨架，你按这个骨架逐个 API 接入就行。

设计与命名完全贴合你产品文档里的"应用 → 模块 → 目录 → 字段"与"第三方模块 Manifest+联邦调用"的思想。 ￼

⸻

一、最小目录（不多一个文件夹）

AINO-server/
  src/
    app.ts              # Hono 实例 + 中间件（CORS/安全头/压缩/限流）
    server.ts           # 启动
    env.ts              # 环境变量校验（Zod）
    db/
      index.ts          # pg Pool + drizzle 实例
      schema.ts         # 只有"平台元数据 + 核心目录"几张表
    lib/
      system-modules.ts # 系统模块配置
    platform/
      identity.ts       # 统一用户上下文（身份契约）
      modules/
        registry.ts     # 模块注册（本地/远程）
        proxy.ts        # 远程模块代理（HMAC）
        manifest.ts     # Manifest 类型（Zod）
    modules/
      users/            # 用户模块（系统模块）
        routes.ts
        service.ts
        repo.ts
        dto.ts
      modules/          # 模块路由系统
        routes.ts
      applications/     # 应用管理
        routes.ts
        service.ts
        repo.ts
        dto.ts
      catalog/          # 你的业务模块（示例）
        routes.ts
        service.ts
        repo.ts
        dto.ts


⸻

二、最小中间件栈（4 个就够）
	•	CORS：前端 AINO-studio 能请求
	•	安全头：secure-headers
	•	压缩：compress（仅 JSON）
	•	限流：用 rate-limiter-flexible 写 20 行中间件即可（读/写不同配额）

// src/app.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { secureHeaders } from 'hono/secure-headers'
import { compress } from 'hono/compress'
import pino from 'pino'
import { usersRoute } from './modules/users/routes'
import { modulesRoute } from './modules/modules/routes'
import { catalogRoute } from './modules/catalog/routes'

export type Vars = { user?: { id: string; roles: string[] } }
export const app = new Hono<{ Variables: Vars }>()

app.use('*', cors(), secureHeaders(), compress())
app.get('/health', (c) => c.text('ok'))

// 系统模块路由
app.route('/api/modules', modulesRoute)

// 直接访问路由（兼容性）
app.route('/api/users', usersRoute)
app.route('/api/catalog', catalogRoute)


⸻

三、数据库只放"平台最小元数据" + 你正在接的目录表

坚持能不建就不建：平台元数据 4 张表 + 你当下要接的业务目录表

// src/db/schema.ts（只保留最小必需）
import { pgTable, varchar, jsonb, timestamp, index, boolean, integer } from 'drizzle-orm/pg-core'

export const applications = pgTable('applications', {
  id: varchar('id', { length: 36 }).primaryKey(),
  name: varchar('name', { length: 64 }).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
})

export const modules = pgTable('modules', {              // 模块表（包含系统模块）
  id: varchar('id', { length: 36 }).primaryKey(),
  applicationId: varchar('application_id', { length: 36 }).notNull().references(() => applications.id),
  name: varchar('name', { length: 64 }).notNull(),
  type: varchar('type', { length: 16 }).notNull(),        // 'system'|'business'|'remote'
  config: jsonb('config').$type<unknown>().notNull(),     // 模块配置
  order: integer('order').default(0),
  isEnabled: boolean('is_enabled').default(true).notNull(),
})

export const directories = pgTable('directories', {      // 目录（业务对象）
  id: varchar('id', { length: 36 }).primaryKey(),
  moduleId: varchar('module_id', { length: 36 }).notNull().references(() => modules.id),
  name: varchar('name', { length: 64 }).notNull(),
}, t => ({ byModule: index('idx_dir_mod').on(t.moduleId) }))

export const fields = pgTable('fields', {                // 字段定义（简单存元信息）
  id: varchar('id', { length: 36 }).primaryKey(),
  directoryId: varchar('directory_id', { length: 36 }).notNull().references(() => directories.id),
  name: varchar('name', { length: 64 }).notNull(),       // 系统名
  schema: jsonb('schema'),                               // Zod/JSONSchema 片段
})

你的自定义目录数据表怎么建？——一步一表：当且仅当前端需要对接该页面时，才为该目录建立实体表（或先用 jsonb extras），避免一次性铺满所有表。

⸻

四、统一身份契约（任何模块都依赖它）

// src/platform/identity.ts
import { z } from 'zod'
export const Identity = z.object({
  id: z.string(), displayName: z.string().optional(),
  roles: z.array(z.string()).default([]),
})
export type TIdentity = z.infer<typeof Identity>

	•	鉴权中间件把 user 放到 c.set('user', identity)，所有模块只认这一种形态。
	•	第三方模块也必须用这个"最小用户态"（你产品文档里强调"模块统一依赖宿主用户"）。 ￼

⸻

五、模块即插即用（本地/远程统一"契约"）

Manifest 最小模型（Zod）：

// src/platform/modules/manifest.ts
import { z } from 'zod'
export const ModuleManifest = z.object({
  key: z.string(), name: z.string(),
  version: z.string(), kind: z.enum(['local','remote']),
  routes: z.array(z.object({ method: z.enum(['GET','POST','PUT','DELETE']), path: z.string() })),
})
export type TModuleManifest = z.infer<typeof ModuleManifest>

注册与代理：
	•	本地模块：直接 app.route('/api/<key>', routes)
	•	远程模块：/api/remote/:key/* 统一代理（fetch + HMAC 签名 + 透传用户 id）

// src/platform/modules/proxy.ts（极简 HMAC 代理）
import { Hono } from 'hono'
import crypto from 'node:crypto'
export const proxy = new Hono()

proxy.all('/:key/*', async (c) => {
  const { key } = c.req.param()
  const target = /* 从 modules.manifest 取远程 baseURL */
  const body = await c.req.arrayBuffer()
  const sign = crypto.createHmac('sha256', process.env.MODULE_HMAC_SECRET!).update(Buffer.from(body)).digest('hex')
  const res = await fetch(target + c.req.path.slice(('/api/remote/'+key).length), {
    method: c.req.method,
    headers: { 'x-platform-user-id': c.get('user')?.id ?? '', 'x-sign': sign, 'content-type': c.req.header('content-type') ?? '' },
    body: ['GET','HEAD'].includes(c.req.method) ? undefined : body,
  })
  return new Response(res.body, { status: res.status, headers: res.headers })
})

这样远程模块与本地模块对前端是"一个样子"，完全符合你"可插拔 + 统一依赖宿主用户"的设定。 ￼

⸻

六、API 开发"最小闭环"（一口一个）

以 GET /api/catalog/items 为例（键集分页，能抗并发）：

// modules/catalog/dto.ts
import { z } from 'zod'
export const Item = z.object({ id: z.string(), name: z.string(), status: z.enum(['draft','active']), createdAt: z.string().datetime() })
export const ItemListQuery = z.object({ size: z.coerce.number().int().min(1).max(100).default(20), cursor: z.string().optional(), status: z.enum(['draft','active']).optional() })
export type TItemListQuery = z.infer<typeof ItemListQuery>

// modules/catalog/repo.ts
import { db } from '../../db'
import { items } from '../../db/schema'  // 仅当这个目录要接 API，才建这张表
import { and, desc, eq, lt } from 'drizzle-orm'

export async function listRepo(q: { size: number; cursor?: Date; status?: 'draft'|'active'}) {
  const where = and(q.status ? eq(items.status, q.status) : undefined, q.cursor ? lt(items.createdAt, q.cursor) : undefined)
  const rows = await db.select().from(items).where(where).orderBy(desc(items.createdAt)).limit(q.size + 1)
  const nextCursor = rows.length > q.size ? rows[q.size - 1].createdAt : null
  return { rows: rows.slice(0, q.size), nextCursor }
}

// modules/catalog/service.ts
import { TItemListQuery } from './dto'
import { listRepo } from './repo'
export async function listItems(q: TItemListQuery) {
  const res = await listRepo({ size: q.size, cursor: q.cursor ? new Date(q.cursor) : undefined, status: q.status })
  return { items: res.rows, nextCursor: res.nextCursor ? res.nextCursor.toISOString() : null }
}

// modules/catalog/routes.ts
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { ItemListQuery } from './dto'
import { listItems } from './service'

export const catalogRoute = new Hono()
catalogRoute.get('/items', zValidator('query', ItemListQuery), async (c) => {
  const q = c.req.valid('query')
  const data = await listItems(q)
  return c.json({ success: true, data })
})


⸻

七、运行与数据库并发（最小而有效）
	•	pg.Pool.max=10；生产用 PgBouncer（transaction 模式）把连接"汇聚"，避免打爆 DB。
	•	列表一律键集分页；写入用 UPSERT；查询只取必要列。
	•	热点（读多写少）给 30–120 秒 Redis 缓存（可等你 QPS 上来再加）。
	•	监控先上最小化：/health + p95 请求时间日志（pino）。

这些是你之前踩坑的"并发守门员"，但都很轻，不会让工程复杂。

⸻

八、约束（简单四条，AI 也不容易跑偏）
	1.	每个 API 必有 DTO（Zod）；路由只接收 c.req.valid() 的数据。
	2.	三层固定：routes → service → repo（repo 里不做业务逻辑）。
	3.	数据库结构最小化：仅为"当前要接"的页面建表；其余先 jsonb extras。
	4.	模块必须有 Manifest；远程一律走 /api/remote/:key/* + HMAC。

⸻

九、你可以立刻执行的 5 步
	1.	按上面目录把 空文件建好；把中间件接上能跑 /health。
	2.	先选 AINO-studio 的一个页面一个接口（如 "商品列表"），照模板接上。
	3.	drizzle:gen && drizzle:push 只生成"那一张表"。
	4.	AINO-studio 改为真实 API，回归通过后再接下一个 API。
	5.	每接完 3–5 个 API，再决定是否给某些字段加索引或做生成列（只优化真实热点）。

⸻

这样做的结果：
	•	架构轻到不能再轻，但边界清晰、能接第三方模块、能长大；
	•	完全对齐你文档里的"四层模型 + 模块生态 + 身份契约 + 远程联邦"的方向（且不复杂）。 ￼


  应用用户模块是 AINO 平台的内置系统模块，用于管理每个应用内的独立用户。每个应用的用户都是完全独立的，通过 `applicationId` 进行隔离。  
  用户模块 不是系统管用户