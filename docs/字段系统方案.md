# AINO å­—æ®µç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº† AINO å¹³å°çš„å­—æ®µç³»ç»Ÿæ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆåŸºäºç”Ÿäº§çº§æ¶æ„è®¾è®¡ï¼Œæ”¯æŒåŠ¨æ€å­—æ®µã€å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼Œä¸ºå¹³å°æä¾›çµæ´»çš„æ•°æ®ç®¡ç†èƒ½åŠ›ã€‚

### âœ… æ ¸å¿ƒç‰¹æ€§

#### 1. ç”Ÿäº§çº§æ¶æ„è®¾è®¡
```typescript
// æ¯ç›®å½•ä¸€å¼ è¡¨ + JSONB å­˜å‚¨
export const dirUsers = pgTable('dir_users', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull(),  // å¤šç§Ÿæˆ·éš”ç¦»
  version: integer('version').notNull().default(1),  // ä¹è§‚é”
  props: jsonb('props').notNull().$type<Record<string, any>>(),  // åŠ¨æ€å­—æ®µ
  // ... å®¡è®¡å­—æ®µ
})
```

**ä¼˜åŠ¿**ï¼š
- âœ… **ç±»å‹å®‰å…¨**ï¼šæ¯ç›®å½•ç‹¬ç«‹è¡¨ï¼ŒDrizzle ç±»å‹æ¨å¯¼å®Œæ•´
- âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šJSONB + GIN ç´¢å¼•ï¼ŒæŸ¥è¯¢æ€§èƒ½ä¼˜ç§€
- âœ… **å¤šç§Ÿæˆ·**ï¼šRLS + tenant_idï¼Œæ•°æ®éš”ç¦»å®‰å…¨
- âœ… **ç‰ˆæœ¬æ§åˆ¶**ï¼šä¹è§‚é”é˜²æ­¢å¹¶å‘å†²çª

#### 2. ç»Ÿä¸€ CRUD API
```typescript
// ä¸€å¥— API å¤„ç†æ‰€æœ‰ç›®å½•
GET /api/records/:dir          // åˆ—è¡¨æŸ¥è¯¢
GET /api/records/:dir/:id      // è¯¦æƒ…æŸ¥è¯¢  
POST /api/records/:dir         // åˆ›å»ºè®°å½•
PATCH /api/records/:dir/:id    // ä¿®æ”¹è®°å½•
DELETE /api/records/:dir/:id   // åˆ é™¤è®°å½•
```

**ä¼˜åŠ¿**ï¼š
- âœ… **å¼€å‘æ•ˆç‡**ï¼šä¸€å¥—ä»£ç å¤„ç†æ‰€æœ‰ä¸šåŠ¡è¡¨
- âœ… **ä¸€è‡´æ€§**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†ã€åˆ†é¡µã€æ’åº
- âœ… **æ‰©å±•æ€§**ï¼šæ·»åŠ ç›®å½•åªéœ€é…ç½®å…ƒæ•°æ®

#### 3. å­—æ®µå¤„ç†å™¨æ¶æ„
```typescript
// æ”¯æŒå¤æ‚å­—æ®µç±»å‹
export const processors = {
  primitive: { /* åŸºç¡€ç±»å‹ */ },
  composite: { /* å¤åˆå¯¹è±¡ */ },
  relation: { /* å…³è”å­—æ®µ */ },
  lookup: { /* å¤–éƒ¨æ•°æ® */ },
  computed: { /* è®¡ç®—å­—æ®µ */ }
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… **ä¸šåŠ¡å­—æ®µæ”¯æŒ**ï¼šcityã€skillsã€experience ç­‰å¤æ‚å­—æ®µ

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ–‡ä»¶ç»“æ„
```
apps/
  server/
    src/
      db/
        schema.ts          # æ•°æ®åº“ schema
        client.ts          # Drizzle å®¢æˆ·ç«¯
      middleware/
        tenant.ts          # ç§Ÿæˆ·æ³¨å…¥ + RLS GUC
        auth.ts            # è®¤è¯ä¸­é—´ä»¶
      lib/
        meta.ts            # è¯»å–å…ƒæ•°æ®
        zod-from-fields.ts # åŠ¨æ€ç”Ÿæˆ Zod æ ¡éªŒå™¨
        jsonb.ts           # JSONB æ¡ä»¶/æ’åº/æŠ•å½±å¸®åŠ©
        processors.ts      # ä¸šåŠ¡å­—æ®µå¤„ç†å™¨
        expand.ts          # å…³è”å±•å¼€
        acl.ts             # å­—æ®µçº§è¯»å†™æ§åˆ¶
      routes/
        records.ts         # ç»Ÿä¸€ CRUD è·¯ç”±
      tasks/
        field-indexes.ts   # å€’æ’ç´¢å¼•å¼‚æ­¥ä»»åŠ¡
        lookup-refresh.ts  # ç¬¬ä¸‰æ–¹ API é‡åˆ·
      index.ts             # Hono åº”ç”¨å…¥å£
    drizzle/
      0001_init.sql        # åˆå§‹å»ºè¡¨
      0002_indexes.sql     # è¡¨è¾¾å¼ç´¢å¼•
      0003_rls.sql         # è¡Œçº§å®‰å…¨ç­–ç•¥
    package.json
```

### æ ¸å¿ƒç»„ä»¶

#### 1. æ•°æ®åº“ Schema
```typescript
// å…ƒæ•°æ®è¡¨
export const directoryDefs = pgTable('directory_defs', {
  id: uuid('id').primaryKey().defaultRandom(),
  slug: text('slug').notNull().unique(),
  title: text('title').notNull(),
  version: integer('version').notNull().default(1),
  status: text('status').notNull().default('active'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
})

export const fieldDefs = pgTable('field_defs', {
  id: uuid('id').primaryKey().defaultRandom(),
  directoryId: uuid('directory_id').notNull().references(() => directoryDefs.id, { onDelete: 'cascade' }),
  key: text('key').notNull(),
  kind: text('kind').notNull(), // 'primitive' | 'composite' | 'relation' | 'lookup' | 'computed'
  type: text('type').notNull(),
  schema: jsonb('schema'),
  relation: jsonb('relation'),
  lookup: jsonb('lookup'),
  computed: jsonb('computed'),
  validators: jsonb('validators'),
  readRoles: jsonb('read_roles').$type<string[]>().default(['admin', 'member']),
  writeRoles: jsonb('write_roles').$type<string[]>().default(['admin']),
  required: boolean('required').default(false),
})

// ä¸šåŠ¡æ•°æ®è¡¨ï¼ˆæ¯ç›®å½•ä¸€å¼ ï¼‰
export const dirUsers = pgTable('dir_users', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull(),
  version: integer('version').notNull().default(1),
  props: jsonb('props').notNull().$type<Record<string, any>>().default({}),
  createdBy: uuid('created_by'),
  updatedBy: uuid('updated_by'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
})
```

#### 2. å­—æ®µå¤„ç†å™¨
```typescript
export const processors = {
  primitive: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) { return v },
    async deserialize(v: any) { return v },
  },
  composite: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // æŒ‰ f.schema åšç»“æ„æ ¡éªŒ/æ ‡å‡†åŒ–
      return v
    },
    async deserialize(v: any) { return v },
  },
  relation: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // å…è®¸ä¼ å•ä¸ªID/URNæˆ–æ•°ç»„ï¼Œç»Ÿä¸€ä¸ºæ•°ç»„å½¢å¼å­˜å‚¨
      const arr = Array.isArray(v) ? v : [v]
      return arr
    },
    async deserialize(v: any) { return v },
  },
  lookup: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // åŒæ­¥"å‡è£…å½’ä¸€åŒ–"ï¼›ç”Ÿäº§ä¸­æ¥å…¥ç¼“å­˜/ç¬¬ä¸‰æ–¹APIå¹¶å¸¦ TTL
      if (typeof v === 'string') return { code: v, name: v, source: f.lookup?.source || 'manual' }
      return v
    },
    async deserialize(v: any) { return v },
  },
  computed: {
    async serialize(_v: any, f: FieldDef, _ctx: Ctx) {
      // writeThrough æ¨¡å¼åœ¨å†™å…¥æ—¶è®¡ç®—
      return _v
    },
    async deserialize(v: any) { return v },
  },
}
```

#### 3. ç»Ÿä¸€ CRUD API
```typescript
// åˆ—è¡¨æŸ¥è¯¢
app.get('/api/records/:dir', async (c) => {
  const dir = c.req.param('dir')
  const t = tableFor(dir)
  const tenantId = c.get('tenantId') as string
  const page = Number(c.req.query('page') ?? '1')
  const pageSize = Math.min(Number(c.req.query('pageSize') ?? '20'), 50)
  const sort = c.req.query('sort') || undefined
  const fields = c.req.query('fields') || undefined
  const filterRaw = c.req.query('filter')

  let where: any = and(eq(t.tenantId, tenantId), sql`${t.deletedAt} is null`)
  if (filterRaw) {
    try {
      const filters = JSON.parse(filterRaw)
      for (const [k, v] of Object.entries(filters)) {
        where = and(where, jsonEq(t.props, k, v))
      }
    } catch {}
  }

  const orderBy = buildOrderBy(t.props, sort)
  const rows = await db.select().from(t).where(where).orderBy(...orderBy).limit(pageSize).offset((page - 1) * pageSize)

  let data = rows.map((r: any) => ({ id: r.id, version: r.version, ...projectProps(r.props, fields) }))
  return c.json({ success: true, data })
})

// åˆ›å»ºè®°å½•
app.post('/api/records/:dir', async (c) => {
  const dir = c.req.param('dir')
  const t = tableFor(dir)
  const tenantId = c.get('tenantId') as string
  const input = await c.req.json()

  const { fields } = await getDirectoryMeta(dir)
  const zod = zodFromFields(fields)
  const clean = zod.parse(input)

  const props: Record<string, any> = {}
  for (const f of fields) {
    if (clean[f.key] === undefined) continue
    props[f.key] = await runSerialize(f.kind as any, clean[f.key], f, { tenantId, now: new Date() })
  }

  const [row] = await db.insert(t).values({ tenantId, props }).returning()
  return c.json({ success: true, data: { id: row.id, version: row.version, ...row.props } })
})
```

## ğŸ¯ ä¸šåŠ¡åœºæ™¯æ”¯æŒ

### 1. åŸºç¡€å­—æ®µ
```typescript
// æ–‡æœ¬å­—æ®µ
{ key: 'name', kind: 'primitive', type: 'text', required: true }

// æ•°å­—å­—æ®µ
{ key: 'age', kind: 'primitive', type: 'number', validators: { min: 0, max: 150 } }

// é€‰æ‹©å­—æ®µ
{ key: 'gender', kind: 'primitive', type: 'select', options: ['ç”·', 'å¥³', 'å…¶ä»–'] }
```

### 2. å¤æ‚ä¸šåŠ¡å­—æ®µ
```typescript
// åŸå¸‚å­—æ®µï¼ˆlookupï¼‰
{ 
  key: 'city', 
  kind: 'lookup', 
  type: 'text', 
  lookup: { source: 'china_divisions' } 
}

// æŠ€èƒ½å­—æ®µï¼ˆcompositeï¼‰
{ 
  key: 'skills', 
  kind: 'composite', 
  type: 'json', 
  schema: { 
    type: 'array', 
    items: { type: 'object', properties: { name: 'string', level: 'number' } } 
  } 
}

// å·¥ä½œç»å†ï¼ˆrelationï¼‰
{ 
  key: 'jobs', 
  kind: 'relation', 
  type: 'json', 
  relation: { targetDir: 'jobs', cardinality: 'NN' } 
}
```

### 3. è®¡ç®—å­—æ®µ
```typescript
// æ€»å·¥ä½œç»éªŒï¼ˆcomputedï¼‰
{ 
  key: 'totalExperience', 
  kind: 'computed', 
  type: 'number', 
  computed: { expr: 'sumMonths(experience)' } 
}
```

## ğŸ”’ å®‰å…¨ä¸æ€§èƒ½

### 1. å¤šç§Ÿæˆ·éš”ç¦»
```sql
-- è¡Œçº§å®‰å…¨ç­–ç•¥
alter table dir_users enable row level security;
create policy p_users_by_tenant on dir_users using (
  tenant_id = current_setting('app.tenant_id')::uuid and deleted_at is null
);
```

### 2. å­—æ®µçº§æƒé™æ§åˆ¶
```typescript
// å­—æ®µçº§ ACL
export function readableKeys(fields: FieldDef[], roles: string[]) {
  return fields.filter(f => (f.readRoles ?? ['admin']).some(r => roles.includes(r))).map(f => f.key)
}

export function writableKeys(fields: FieldDef[], roles: string[]) {
  return fields.filter(f => (f.writeRoles ?? ['admin']).some(r => roles.includes(r))).map(f => f.key)
}
```

### 3. æ€§èƒ½ä¼˜åŒ–
```sql
-- JSONB GIN ç´¢å¼•
create index idx_users_props_gin on dir_users using gin(props jsonb_path_ops);

-- é«˜é¢‘ç­›é€‰å­—æ®µç´¢å¼•
create index idx_users_city on dir_users ((props->>'city'));

-- æ•°å€¼æ’åºç´¢å¼•
create index idx_users_score on dir_users (((props->>'score')::numeric));
```
