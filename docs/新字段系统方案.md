# 新字段系统方案设计文档

## 📋 概述

本文档描述了 AINO 平台的新字段系统方案，该方案基于生产级架构设计，支持动态字段、复杂业务场景，并与现有系统完美融合。

## 🎯 为什么选择这个方案

### ✅ 核心优势分析

#### 1. 生产级架构设计
```typescript
// 每目录一张表 + JSONB 存储
export const dirUsers = pgTable('dir_users', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull(),  // 多租户隔离
  version: integer('version').notNull().default(1),  // 乐观锁
  props: jsonb('props').notNull().$type<Record<string, any>>(),  // 动态字段
  // ... 审计字段
})
```

**优势**：
- ✅ **类型安全**：每目录独立表，Drizzle 类型推导完整
- ✅ **性能优化**：JSONB + GIN 索引，查询性能优秀
- ✅ **多租户**：RLS + tenant_id，数据隔离安全
- ✅ **版本控制**：乐观锁防止并发冲突

#### 2. 统一 CRUD API
```typescript
// 一套 API 处理所有目录
GET /api/records/:dir          // 列表查询
GET /api/records/:dir/:id      // 详情查询  
POST /api/records/:dir         // 创建记录
PATCH /api/records/:dir/:id    // 更新记录
DELETE /api/records/:dir/:id   // 删除记录
```

**优势**：
- ✅ **开发效率**：一套代码处理所有业务表
- ✅ **一致性**：统一的错误处理、分页、排序
- ✅ **扩展性**：新增目录只需配置元数据

#### 3. 字段处理器架构
```typescript
// 支持复杂字段类型
export const processors = {
  primitive: { /* 基础类型 */ },
  composite: { /* 复合对象 */ },
  relation: { /* 关联字段 */ },
  lookup: { /* 外部数据 */ },
  computed: { /* 计算字段 */ }
}
```

**优势**：
- ✅ **业务字段支持**：city、skills、experience 等复杂字段
- ✅ **第三方集成**：lookup 支持外部 API 数据
- ✅ **计算能力**：computed 支持公式计算

#### 4. 与现有系统完美融合
```typescript
// 保留现有字段分类功能
export const fieldCategories = pgTable("field_categories", {
  // ... 现有字段分类表结构
})

// 新方案作为字段系统的核心
export const fieldDefs = pgTable('field_defs', {
  // ... 新字段定义表
})
```

**优势**：
- ✅ **向后兼容**：不影响现有功能
- ✅ **渐进迁移**：可以逐步迁移到新方案
- ✅ **功能增强**：在现有基础上增加强大能力

## 📊 当前实施状态

### ✅ 已完成的工作

#### 1. 基础架构准备
- ✅ 删除了旧的字段模块（fields 表、API、前端代码）
- ✅ 保留了字段分类功能（field_categories 表）
- ✅ 数据库结构已清理完成

#### 2. 现有系统状态
```typescript
// 当前可用的功能
✅ 字段分类管理 - 完全正常
✅ 目录管理 - 完全正常  
✅ 应用管理 - 完全正常
✅ 用户管理 - 完全正常
✅ 前端界面 - 完全正常
```

### 🚧 准备实施的工作

#### 阶段1：核心架构（优先级：高）
```typescript
// 1. 数据库 schema 设计
- directoryDefs 表（目录定义）
- fieldDefs 表（字段定义）
- dirUsers 表（示例目录表）

// 2. 基础 API 实现
- 统一 CRUD 路由
- 字段处理器
- 租户中间件

// 3. 前端集成
- 动态表单生成
- 字段类型支持
- 数据展示组件
```

#### 阶段2：高级功能（优先级：中）
```typescript
// 1. 复杂字段支持
- lookup 字段（城市、技能等）
- relation 字段（关联数据）
- computed 字段（计算值）

// 2. 性能优化
- JSONB 索引
- 倒排索引
- 缓存机制

// 3. 业务集成
- 第三方 API 集成
- 数据同步任务
- 审计日志
```

#### 阶段3：生产优化（优先级：低）
```typescript
// 1. 安全加固
- 字段级 ACL
- 数据验证
- 权限控制

// 2. 运维支持
- 监控告警
- 数据备份
- 性能分析
```

## 🔄 与现有系统融合方案

### 1. 渐进式迁移策略
```typescript
// 第一步：并行运行
现有系统：字段分类 + 静态字段
新系统：动态字段 + 统一 CRUD

// 第二步：功能增强
在现有目录基础上添加动态字段支持

// 第三步：完全迁移
逐步将静态字段迁移到动态字段系统
```

### 2. 兼容性保证
```typescript
// 保留现有 API
GET /api/field-categories  // 继续支持
GET /api/directories       // 继续支持

// 新增统一 API
GET /api/records/:dir      // 新功能
POST /api/records/:dir     // 新功能
```

### 3. 前端适配
```typescript
// 现有组件继续工作
<FieldCategoryManager />   // 字段分类管理
<DirectoryManager />       // 目录管理

// 新增动态组件
<DynamicForm />           // 动态表单
<DynamicTable />          // 动态表格
```

## 📅 实施计划

### 立即开始（本周）
1. **数据库 schema 设计**
   - 创建 directoryDefs 和 fieldDefs 表
   - 设计示例目录表结构

2. **核心 API 开发**
   - 实现统一 CRUD 路由
   - 开发字段处理器

3. **前端基础组件**
   - 动态表单生成器
   - 字段类型渲染器

### 下周计划
1. **复杂字段支持**
   - lookup 字段实现
   - relation 字段实现

2. **性能优化**
   - JSONB 索引优化
   - 查询性能调优

3. **业务集成**
   - 与现有字段分类集成
   - 数据迁移工具

### 长期目标
1. **生产就绪**
   - 完整的错误处理
   - 全面的测试覆盖
   - 性能监控

2. **功能完善**
   - 高级查询功能
   - 数据导入导出
   - 报表生成

## 🏗️ 技术架构

### 文件结构
```
apps/
  server/
    src/
      db/
        schema.ts          # 数据库 schema
        client.ts          # Drizzle 客户端
      middleware/
        tenant.ts          # 租户注入 + RLS GUC
        auth.ts            # 认证中间件
      lib/
        meta.ts            # 读取元数据
        zod-from-fields.ts # 动态生成 Zod 校验器
        jsonb.ts           # JSONB 条件/排序/投影帮助
        processors.ts      # 业务字段处理器
        expand.ts          # 关联展开
        acl.ts             # 字段级读写控制
      routes/
        records.ts         # 统一 CRUD 路由
      tasks/
        field-indexes.ts   # 倒排索引异步任务
        lookup-refresh.ts  # 第三方 API 重刷
      index.ts             # Hono 应用入口
    drizzle/
      0001_init.sql        # 初始建表
      0002_indexes.sql     # 表达式索引
      0003_rls.sql         # 行级安全策略
    package.json
```

### 核心组件

#### 1. 数据库 Schema
```typescript
// 元数据表
export const directoryDefs = pgTable('directory_defs', {
  id: uuid('id').primaryKey().defaultRandom(),
  slug: text('slug').notNull().unique(),
  title: text('title').notNull(),
  version: integer('version').notNull().default(1),
  status: text('status').notNull().default('active'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
})

export const fieldDefs = pgTable('field_defs', {
  id: uuid('id').primaryKey().defaultRandom(),
  directoryId: uuid('directory_id').notNull().references(() => directoryDefs.id, { onDelete: 'cascade' }),
  key: text('key').notNull(),
  kind: text('kind').notNull(), // 'primitive' | 'composite' | 'relation' | 'lookup' | 'computed'
  type: text('type').notNull(),
  schema: jsonb('schema'),
  relation: jsonb('relation'),
  lookup: jsonb('lookup'),
  computed: jsonb('computed'),
  validators: jsonb('validators'),
  readRoles: jsonb('read_roles').$type<string[]>().default(['admin', 'member']),
  writeRoles: jsonb('write_roles').$type<string[]>().default(['admin']),
  required: boolean('required').default(false),
})

// 业务数据表（每目录一张）
export const dirUsers = pgTable('dir_users', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull(),
  version: integer('version').notNull().default(1),
  props: jsonb('props').notNull().$type<Record<string, any>>().default({}),
  createdBy: uuid('created_by'),
  updatedBy: uuid('updated_by'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
})
```

#### 2. 字段处理器
```typescript
export const processors = {
  primitive: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) { return v },
    async deserialize(v: any) { return v },
  },
  composite: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // 按 f.schema 做结构校验/标准化
      return v
    },
    async deserialize(v: any) { return v },
  },
  relation: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // 允许传单个ID/URN或数组，统一为数组形式存储
      const arr = Array.isArray(v) ? v : [v]
      return arr
    },
    async deserialize(v: any) { return v },
  },
  lookup: {
    async serialize(v: any, f: FieldDef, _ctx: Ctx) {
      // 同步"假装归一化"；生产中接入缓存/第三方API并带 TTL
      if (typeof v === 'string') return { code: v, name: v, source: f.lookup?.source || 'manual' }
      return v
    },
    async deserialize(v: any) { return v },
  },
  computed: {
    async serialize(_v: any, f: FieldDef, _ctx: Ctx) {
      // writeThrough 模式在写入时计算
      return _v
    },
    async deserialize(v: any) { return v },
  },
}
```

#### 3. 统一 CRUD API
```typescript
// 列表查询
app.get('/api/records/:dir', async (c) => {
  const dir = c.req.param('dir')
  const t = tableFor(dir)
  const tenantId = c.get('tenantId') as string
  const page = Number(c.req.query('page') ?? '1')
  const pageSize = Math.min(Number(c.req.query('pageSize') ?? '20'), 50)
  const sort = c.req.query('sort') || undefined
  const fields = c.req.query('fields') || undefined
  const filterRaw = c.req.query('filter')

  let where: any = and(eq(t.tenantId, tenantId), sql`${t.deletedAt} is null`)
  if (filterRaw) {
    try {
      const filters = JSON.parse(filterRaw)
      for (const [k, v] of Object.entries(filters)) {
        where = and(where, jsonEq(t.props, k, v))
      }
    } catch {}
  }

  const orderBy = buildOrderBy(t.props, sort)
  const rows = await db.select().from(t).where(where).orderBy(...orderBy).limit(pageSize).offset((page - 1) * pageSize)

  let data = rows.map((r: any) => ({ id: r.id, version: r.version, ...projectProps(r.props, fields) }))
  return c.json({ success: true, data })
})

// 创建记录
app.post('/api/records/:dir', async (c) => {
  const dir = c.req.param('dir')
  const t = tableFor(dir)
  const tenantId = c.get('tenantId') as string
  const input = await c.req.json()

  const { fields } = await getDirectoryMeta(dir)
  const zod = zodFromFields(fields)
  const clean = zod.parse(input)

  const props: Record<string, any> = {}
  for (const f of fields) {
    if (clean[f.key] === undefined) continue
    props[f.key] = await runSerialize(f.kind as any, clean[f.key], f, { tenantId, now: new Date() })
  }

  const [row] = await db.insert(t).values({ tenantId, props }).returning()
  return c.json({ success: true, data: { id: row.id, version: row.version, ...row.props } })
})
```

## 🎯 业务场景支持

### 1. 基础字段
```typescript
// 文本字段
{ key: 'name', kind: 'primitive', type: 'text', required: true }

// 数字字段
{ key: 'age', kind: 'primitive', type: 'number', validators: { min: 0, max: 150 } }

// 选择字段
{ key: 'gender', kind: 'primitive', type: 'select', options: ['男', '女', '其他'] }
```

### 2. 复杂业务字段
```typescript
// 城市字段（lookup）
{ 
  key: 'city', 
  kind: 'lookup', 
  type: 'text', 
  lookup: { source: 'china_divisions' } 
}

// 技能字段（composite）
{ 
  key: 'skills', 
  kind: 'composite', 
  type: 'json', 
  schema: { 
    type: 'array', 
    items: { type: 'object', properties: { name: 'string', level: 'number' } } 
  } 
}

// 工作经历（relation）
{ 
  key: 'jobs', 
  kind: 'relation', 
  type: 'json', 
  relation: { targetDir: 'jobs', cardinality: 'NN' } 
}
```

### 3. 计算字段
```typescript
// 总工作经验（computed）
{ 
  key: 'totalExperience', 
  kind: 'computed', 
  type: 'number', 
  computed: { expr: 'sumMonths(experience)' } 
}
```

## 🔒 安全与性能

### 1. 多租户隔离
```sql
-- 行级安全策略
alter table dir_users enable row level security;
create policy p_users_by_tenant on dir_users using (
  tenant_id = current_setting('app.tenant_id')::uuid and deleted_at is null
);
```

### 2. 字段级权限控制
```typescript
// 字段级 ACL
export function readableKeys(fields: FieldDef[], roles: string[]) {
  return fields.filter(f => (f.readRoles ?? ['admin']).some(r => roles.includes(r))).map(f => f.key)
}

export function writableKeys(fields: FieldDef[], roles: string[]) {
  return fields.filter(f => (f.writeRoles ?? ['admin']).some(r => roles.includes(r))).map(f => f.key)
}
```

### 3. 性能优化
```sql
-- JSONB GIN 索引
create index idx_users_props_gin on dir_users using gin(props jsonb_path_ops);

-- 高频筛选字段索引
create index idx_users_city on dir_users ((props->>'city'));

-- 数值排序索引
create index idx_users_score on dir_users (((props->>'score')::numeric));
```

## 📈 总结

这个新字段系统方案具有以下特点：

1. **技术先进**：JSONB + 统一 API + 字段处理器
2. **生产就绪**：多租户 + 版本控制 + 性能优化
3. **业务友好**：支持复杂字段类型和业务场景
4. **系统兼容**：与现有系统完美融合，渐进迁移

通过这个方案，AINO 平台将具备强大的动态字段能力，能够支持各种复杂的业务场景，同时保持系统的稳定性和可扩展性。
